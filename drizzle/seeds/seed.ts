// Assuming your schema.ts is in the same directory or accessible via import
import {
  accounts,
  bookmarks,
  claps,
  comments,
  follows,
  posts,
  postTags,
  sessions,
  tags,
  users,
} from "../schema";

import * as dotenv from "dotenv";
import { drizzle } from "drizzle-orm/node-postgres";
import { Pool } from "pg";

dotenv.config({ path: "./.env" });

const pool = new Pool({
  connectionString: process.env.DATABASE_URL,
});
const db = drizzle(pool);

import { faker } from "@faker-js/faker";

// --- Configuration ---
const USERS_COUNT = 10;
const TAGS_COUNT = 5;
const POSTS_PER_USER = 5;
const CLAPS_PER_POST = 3;
const COMMENTS_PER_POST = 2;
const FOLLOWS_PER_USER = 2;
const BOOKMARKS_PER_USER = 1;

// --- Mock Data Generators ---

function createMockUser() {
  const firstName = faker.person.firstName();
  const lastName = faker.person.lastName();
  const email = faker.internet.email({ firstName, lastName });

  return {
    // id is auto-generated by the schema helper
    name: `${firstName} ${lastName}`,
    email: email,
    emailVerified: faker.datatype.boolean(0.8), // 80% chance of being verified
    image: faker.image.avatar(),
    bio: faker.lorem.paragraph(1).slice(0, 255),
    avatarUrl: faker.image.avatar(),
    // deletedAt is null
  };
}

function createMockTag() {
  return {
    // id is auto-generated
    name: faker.lorem.word({ length: { min: 4, max: 10 } }),
  };
}

function createMockPost(authorId: string) {
  const title = faker.lorem.sentence({ min: 5, max: 10 }).slice(0, 255);
  const slug = title
    .toLowerCase()
    .replace(/[^\w\s-]/g, "")
    .trim()
    .replace(/[-\s]+/g, "-")
    .slice(0, 255);
  const statusOptions = ["draft", "published", "archived"] as const;
  const status = faker.helpers.arrayElement(statusOptions);
  const publishedAt =
    status === "published"
      ? faker.date.past({ years: 1 })
      : status === "archived"
      ? faker.date.past({ years: 2 })
      : undefined;

  return {
    // id is auto-generated
    authorId: authorId,
    title: title,
    subtitle: faker.lorem.sentence({ min: 3, max: 6 }).slice(0, 255),
    content: faker.lorem.paragraphs(3),
    slug: `${slug}-${faker.string.numeric(5)}`, // Add a random suffix to ensure uniqueness
    status: status,
    publishedAt: publishedAt,
    // deletedAt is null
  };
}

function createMockClap(postId: string, userId: string) {
  return {
    // id is auto-generated
    postId: postId,
    userId: userId,
    clapCount: faker.number.int({ min: 1, max: 50 }),
  };
}

function createMockComment(postId: string, userId: string, parentId?: string) {
  return {
    // id is auto-generated
    postId: postId,
    userId: userId,
    parentId: parentId,
    content: faker.lorem.sentence({ min: 5, max: 20 }),
    // deletedAt is null
  };
}

function createMockSession(userId: string) {
  return {
    // id is auto-generated
    expiresAt: faker.date.future({ years: 1 }),
    token: faker.string.uuid(),
    ipAddress: faker.internet.ip(),
    userAgent: faker.internet.userAgent(),
    userId: userId,
  };
}

function createMockAccount(userId: string) {
  const provider = faker.helpers.arrayElement(["google", "credentials"]);
  return {
    // id is auto-generated
    accountId: faker.string.uuid(),
    providerId: provider,
    userId: userId,
    // only set password if provider is credentials
    password:
      provider === "credentials" ? faker.internet.password() : undefined,
    // other OAuth fields can be set but are optional for credentials
  };
}

// --- Main Seeding Function ---

async function seed() {
  console.log("Starting seed script...");

  // 1. Clean up existing data (optional, but good for idempotent seeding)
  console.log("Truncating tables...");
  // Truncate tables in reverse dependency order (and then in batches)
  // NOTE: This is a destructive operation! Only run on development/test databases.
  await db.execute(/*sql*/ `
        TRUNCATE TABLE bookmarks, follows, comments, claps, post_tags, posts, sessions, accounts, verifications, users, tags RESTART IDENTITY CASCADE;
    `);
  console.log("Truncation complete.");

  // 2. Insert primary data (Users and Tags)
  console.log("Inserting users...");
  const usersData = Array.from({ length: USERS_COUNT }, () => createMockUser());
  const insertedUsers = await db
    .insert(users)
    .values(usersData)
    .returning({ id: users.id });
  const userIds = insertedUsers.map((u) => u.id);
  console.log(`Inserted ${userIds.length} users.`);

  console.log("Inserting tags...");
  const tagsData = Array.from({ length: TAGS_COUNT }, () => createMockTag());
  const insertedTags = await db
    .insert(tags)
    .values(tagsData)
    .returning({ id: tags.id });
  const tagIds = insertedTags.map((t) => t.id);
  console.log(`Inserted ${tagIds.length} tags.`);

  // 3. Insert dependent data (Posts, Sessions, Accounts, Verifications)
  const allPosts: { id: string; authorId: string }[] = [];
  const allPostTags: { postId: string; tagId: string }[] = [];
  const allClaps: { postId: string; userId: string; clapCount: number }[] = [];
  const allComments: {
    id: string;
    postId: string;
    userId: string;
    parentId: string | null;
  }[] = [];
  const allFollows: { followerId: string; followeeId: string }[] = [];
  const allBookmarks: { userId: string; postId: string }[] = [];

  for (const userId of userIds) {
    // Sessions and Accounts
    await db.insert(sessions).values(createMockSession(userId));
    await db.insert(accounts).values(createMockAccount(userId));
    // Optional: Verifications (less critical for mock data)
    // await db.insert(verifications).values(createMockVerification(userId));

    // Posts
    for (let i = 0; i < POSTS_PER_USER; i++) {
      const postData = createMockPost(userId);
      const [insertedPost] = await db
        .insert(posts)
        .values(postData)
        .returning({ id: posts.id, authorId: posts.authorId });
      allPosts.push(insertedPost);

      // PostTags (many-to-many)
      const tagsToAssign = faker.helpers.arrayElements(tagIds, {
        min: 1,
        max: 3,
      });
      tagsToAssign.forEach((tagId) => {
        allPostTags.push({ postId: insertedPost.id, tagId });
      });

      // Claps
      const clappers = faker.helpers.arrayElements(
        userIds.filter((id) => id !== userId),
        { min: 1, max: CLAPS_PER_POST }
      );
      clappers.forEach((clapperId) => {
        allClaps.push(createMockClap(insertedPost.id, clapperId));
      });

      // Bookmarks
      if (faker.datatype.boolean(0.4)) {
        // 40% chance the author bookmarks their own post
        allBookmarks.push({ userId: userId, postId: insertedPost.id });
      }

      // Comments (Parent Comments)
      const parentCommenters = faker.helpers.arrayElements(
        userIds.filter((id) => id !== userId),
        { min: 1, max: COMMENTS_PER_POST }
      );
      for (const commenterId of parentCommenters) {
        const [insertedComment] = await db
          .insert(comments)
          .values(createMockComment(insertedPost.id, commenterId))
          .returning({
            id: comments.id,
            postId: comments.postId,
            userId: comments.userId,
            parentId: comments.parentId,
          });

        allComments.push(insertedComment);

        // Optional: Reply Comment
        if (faker.datatype.boolean(0.5)) {
          // 50% chance of a reply
          const replyCommenterId = faker.helpers.arrayElement(
            userIds.filter((id) => id !== commenterId)
          );
          await db
            .insert(comments)
            .values(
              createMockComment(
                insertedPost.id,
                replyCommenterId,
                insertedComment.id
              )
            );
        }
      }
    }

    // Follows
    const followees = faker.helpers.arrayElements(
      userIds.filter((id) => id !== userId),
      { min: 0, max: FOLLOWS_PER_USER }
    );
    followees.forEach((followeeId) => {
      allFollows.push({ followerId: userId, followeeId });
    });

    // Bookmarks (Other users bookmarking)
    const otherBookmarkers = faker.helpers.arrayElements(
      allPosts.map((p) => p.id),
      { min: 0, max: BOOKMARKS_PER_USER }
    );
    otherBookmarkers.forEach((postId) => {
      allBookmarks.push({ userId: userId, postId: postId });
    });
  }

  console.log(`Inserted ${allPosts.length} posts.`);

  // 4. Insert many-to-many/junction tables (batch inserts for performance)
  console.log("Inserting postTags...");
  // Filter for unique post tags to avoid Drizzle throwing an error on the unique constraint
  const uniquePostTags = allPostTags.filter(
    (tag, index, self) =>
      index ===
      self.findIndex((t) => t.postId === tag.postId && t.tagId === tag.tagId)
  );
  if (uniquePostTags.length > 0) {
    await db.insert(postTags).values(uniquePostTags);
  }
  console.log(`Inserted ${uniquePostTags.length} unique post tags.`);

  console.log("Inserting claps...");
  // Filter for unique claps
  const uniqueClaps = allClaps.filter(
    (clap, index, self) =>
      index ===
      self.findIndex(
        (c) => c.postId === clap.postId && c.userId === clap.userId
      )
  );
  if (uniqueClaps.length > 0) {
    await db.insert(claps).values(uniqueClaps);
  }
  console.log(`Inserted ${uniqueClaps.length} unique claps.`);

  console.log("Inserting follows...");
  // Filter for unique follows
  const uniqueFollows = allFollows.filter(
    (follow, index, self) =>
      index ===
      self.findIndex(
        (f) =>
          f.followerId === follow.followerId &&
          f.followeeId === follow.followeeId
      )
  );
  if (uniqueFollows.length > 0) {
    await db.insert(follows).values(uniqueFollows);
  }
  console.log(`Inserted ${uniqueFollows.length} unique follows.`);

  console.log("Inserting bookmarks...");
  // Filter for unique bookmarks
  const uniqueBookmarks = allBookmarks.filter(
    (bookmark, index, self) =>
      index ===
      self.findIndex(
        (b) => b.userId === bookmark.userId && b.postId === bookmark.postId
      )
  );
  if (uniqueBookmarks.length > 0) {
    await db.insert(bookmarks).values(uniqueBookmarks);
  }
  console.log(`Inserted ${uniqueBookmarks.length} unique bookmarks.`);

  console.log("Seed script finished successfully! 🎉");
}

seed()
  .catch((err) => {
    console.error("Seed failed:", err);
    process.exit(1);
  })
  .finally(() => {
    pool.end();
  });
